#!/bin/sh

username="samsterjam"
user_password=""



draw_title() {
    # ASCII art logo - drawn line by line
    ascii_line1=" _____                     _            ___                 "
    ascii_line2="/  ___|                   | |          |_  |                "
    ascii_line3="\ \`--.  __ _ _ __ ___  ___| |_ ___ _ __  | | __ _ _ __ ___  "
    ascii_line4=" \`--. \/ _\` | '_ \` _ \/ __| __/ _ \ '__| | |/ _\` | '_ \` _ \ "
    ascii_line5="/\__/ / (_| | | | | | \__ \ ||  __/ |/\__/ / (_| | | | | | |"
    ascii_line6="\____/ \__,_|_| |_| |_|___/\__\___|_|\____/ \__,_|_| |_| |_|"

    # Draw each line centered
    ascii_row=$((start_row + padding + 1))
    ascii_start=$((start_col + (box_inner_width - ${#ascii_line1}) / 2 + 1))
    printf '\033[%d;%dH\033[1m%s\033[0m' "$ascii_row" "$ascii_start" "$ascii_line1"

    ascii_row=$((ascii_row + 1))
    ascii_start=$((start_col + (box_inner_width - ${#ascii_line2}) / 2 + 1))
    printf '\033[%d;%dH\033[1m%s\033[0m' "$ascii_row" "$ascii_start" "$ascii_line2"

    ascii_row=$((ascii_row + 1))
    ascii_start=$((start_col + (box_inner_width - ${#ascii_line3}) / 2 + 1))
    printf '\033[%d;%dH\033[1m%s\033[0m' "$ascii_row" "$ascii_start" "$ascii_line3"

    ascii_row=$((ascii_row + 1))
    ascii_start=$((start_col + (box_inner_width - ${#ascii_line4}) / 2 + 1))
    printf '\033[%d;%dH\033[1m%s\033[0m' "$ascii_row" "$ascii_start" "$ascii_line4"

    ascii_row=$((ascii_row + 1))
    ascii_start=$((start_col + (box_inner_width - ${#ascii_line5}) / 2 + 1))
    printf '\033[%d;%dH\033[1m%s\033[0m' "$ascii_row" "$ascii_start" "$ascii_line5"

    ascii_row=$((ascii_row + 1))
    ascii_start=$((start_col + (box_inner_width - ${#ascii_line6}) / 2 + 1))
    printf '\033[%d;%dH\033[1m%s\033[0m' "$ascii_row" "$ascii_start" "$ascii_line6"
}


# Helper: repeat a character N times
repeat_char() {
    char="$1"
    count="$2"
    [ "$count" -lt 1 ] && return
    _repeat_i=1
    while [ "$_repeat_i" -le "$count" ]; do
        printf '%s' "$char"
        _repeat_i=$((_repeat_i + 1))
    done
}

# Helper: draw a box at given position
draw_box_at() {
    box_row="$1"
    box_col="$2"
    inner_width="$3"
    inner_height="$4"
    fill_inside="${5:-0}"

    # Top border
    printf '\033[%d;%dH┌' "$box_row" "$box_col"
    repeat_char '─' "$inner_width"
    printf '┐'

    # Sides
    _box_i=1
    while [ "$_box_i" -le "$inner_height" ]; do
        printf '\033[%d;%dH│' $((box_row + _box_i)) "$box_col"
        [ "$fill_inside" -eq 1 ] && repeat_char ' ' "$inner_width"
        printf '\033[%d;%dH│' $((box_row + _box_i)) $((box_col + inner_width + 1))
        _box_i=$((_box_i + 1))
    done

    # Bottom border
    printf '\033[%d;%dH└' $((box_row + inner_height + 1)) "$box_col"
    repeat_char '─' "$inner_width"
    printf '┘'
}

# Cleanup on exit
cleanup() {
    printf '\033[?25h\033[?1049l'
    stty echo icanon
    clear
    exit "${1:-0}"
}

# Ctrl+C handler
handle_sigint() {
    cleanup 0
}

# Main TUI
user_setup_tui() {
    # Get terminal dimensions
    if command -v tput >/dev/null 2>&1; then
        term_rows=$(tput lines)
        term_cols=$(tput cols)
    else
        size=$(stty size 2>/dev/null)
        term_rows=${size%% *}
        term_cols=${size##* }
    fi
    : "${term_rows:=24}"
    : "${term_cols:=80}"

    # Setup
    padding=2
    border_width=2
    box_inner_width=70
    box_width=$((box_inner_width + border_width))

    start_col=$(((term_cols - box_width) / 2))
    [ "$start_col" -lt 1 ] && start_col=1

    # Save cursor and enter alt screen
    printf '\033[?1049h\033[H\033[2J\033[?25l'
    stty -echo -icanon

    trap 'handle_sigint' INT
    trap 'cleanup 1' TERM


    # === SCREEN 2: Password Input ===
    password_screen() {
        box_inner_height=13
        box_height=$((box_inner_height + border_width))
        start_row=$(((term_rows - box_height) / 2))
        [ "$start_row" -lt 1 ] && start_row=1

        printf '\033[H\033[2J'
        draw_box_at "$start_row" "$start_col" "$box_inner_width" "$box_inner_height" 0

        draw_title
        title_row=$((start_row + padding + 4))
        title_col=$((start_col + (box_inner_width - ${#title}) / 2 + 1))
        printf '\033[%d;%dH\033[1m%s\033[0m' "$title_row" "$title_col" "$title"

        subtitle_row=$((title_row + 1))
        subtitle_col=$((start_col + padding + 4))
        printf '\033[%d;%dH%s' "$subtitle_row" "$subtitle_col" "$subtitle"

        info_row=$((subtitle_row + 1))
        strength_display_row="$info_row"
        strength_display_col=$((start_col + padding + 2))

        input_row=$((info_row + 2))
        input_col=$((start_col + padding + 2))

        # Input box
        input_box_width=$((box_inner_width - padding * 2 - 4))
        printf '\033[%d;%dH┌' "$input_row" "$input_col"
        repeat_char '─' "$input_box_width"
        printf '┐'
        printf '\033[%d;%dH│' $((input_row + 1)) "$input_col"
        printf '\033[%d;%dH│' $((input_row + 1)) $((input_col + input_box_width + 1))
        printf '\033[%d;%dH└' $((input_row + 2)) "$input_col"
        repeat_char '─' "$input_box_width"
        printf '┘'

        # Input field position
        field_row=$((input_row + 1))
        field_col=$((input_col + 2))
        max_password_len=$((input_box_width - 2))

        password_input=""
        cursor_pos=0

        # Draw password (as asterisks) - initial draw only
        draw_password() {
            printf '\033[%d;%dH%s' "$field_row" "$field_col" "$1"
            remaining=$((max_password_len - ${#1}))
            if [ "$remaining" -gt 0 ]; then
                repeat_char ' ' "$remaining"
            fi
        }


        # Initial draw - empty field
        draw_password ""
        printf '\033[?25h'
        printf '\033[%d;%dH' "$field_row" $((field_col + cursor_pos))

        while true; do
            char=$(dd bs=1 count=1 2>/dev/null)

            if [ "$char" = "$(printf '\033')" ]; then
                dd bs=1 count=1 2>/dev/null | read -r _ 2>/dev/null
                char=$(dd bs=1 count=1 2>/dev/null)

                case "$char" in
                    C) # Right
                        if [ "$cursor_pos" -lt "${#password_input}" ]; then
                            cursor_pos=$((cursor_pos + 1))
                            printf '\033[%d;%dH' "$field_row" $((field_col + cursor_pos))
                        fi
                        ;;
                    D) # Left
                        if [ "$cursor_pos" -gt 0 ]; then
                            cursor_pos=$((cursor_pos - 1))
                            printf '\033[%d;%dH' "$field_row" $((field_col + cursor_pos))
                        fi
                        ;;
                esac
            elif [ "$char" = "$(printf '\177')" ]; then
                # Backspace
                if [ "$cursor_pos" -gt 0 ]; then
                    before=$(echo "$password_input" | awk -v pos="$cursor_pos" '{print substr($0, 1, pos-1)}')
                    after=$(echo "$password_input" | awk -v pos="$cursor_pos" '{print substr($0, pos+1)}')
                    password_input="${before}${after}"
                    cursor_pos=$((cursor_pos - 1))
                    # Only redraw from new cursor position to end
                    after_cursor=$(echo "$password_input" | awk -v pos="$cursor_pos" '{print substr($0, pos+1)}')
                    printf '\033[%d;%dH' "$field_row" $((field_col + cursor_pos))
                    i=0
                    while [ "$i" -lt "${#after_cursor}" ]; do
                        printf '*'
                        i=$((i + 1))
                    done
                    printf ' '
                    printf '\033[%d;%dH' "$field_row" $((field_col + cursor_pos))
                fi
            elif [ "$char" = "$(printf '\n')" ] || [ "$char" = "$(printf '\r')" ]; then
                # Enter - validate password (allow any non-empty password)
                if [ -z "$password_input" ]; then
                    error_row=$((input_row + 3))
                    error_msg="\033[31mPassword cannot be empty\033[0m"
                    error_col=$((start_col + padding + 3))
                    printf '\033[%d;%dH%b' "$error_row" "$error_col" "$error_msg"
                    sleep 1
                    printf '\033[%d;%dH' "$error_row" "$error_col"
                    repeat_char ' ' 50
                else
                    user_password="$password_input"
                    printf '\033[?25l'
                    return $?
                fi
            else
                # Regular character input
                # Accept any printable character for password
                if [ "${#password_input}" -lt "$max_password_len" ]; then
                    if [ "$cursor_pos" -eq 0 ]; then
                        password_input="${char}${password_input}"
                    elif [ "$cursor_pos" -eq "${#password_input}" ]; then
                        password_input="${password_input}${char}"
                    else
                        before=$(echo "$password_input" | awk -v pos="$cursor_pos" '{print substr($0, 1, pos)}')
                        after=$(echo "$password_input" | awk -v pos="$cursor_pos" '{print substr($0, pos+1)}')
                        password_input="${before}${char}${after}"
                    fi
                    cursor_pos=$((cursor_pos + 1))
                    # Only redraw from previous cursor position to end
                    from_cursor=$(echo "$password_input" | awk -v pos="$cursor_pos" '{print substr($0, pos)}')
                    printf '\033[%d;%dH' "$field_row" $((field_col + cursor_pos - 1))
                    i=0
                    while [ "$i" -lt "${#from_cursor}" ]; do
                        printf '*'
                        i=$((i + 1))
                    done
                    printf '\033[%d;%dH' "$field_row" $((field_col + cursor_pos))
                fi
            fi
        done
    }

    password_screen
}


user_setup_tui


echo $user_password | sudo -S -u $username startx

exit $?
